module Expr_Tree where

-- first, anything in ( parens ) needs to be its own tree.
-- then, find highest infix operator and split the string into two subtrees
-- around that
-- do that until there are no more infix ops.
-- then, check for a prefix op.
-- finally, every leaf of the tree is a lit or an identifier.

import SouC_Types
import SouC_Expr
import Basics

import qualified Data.Map.Strict as Map
import qualified Data.Set as Set
import Data.Word (Word8)
import Text.Parsec (Parsec, runParser, eof, try, lookAhead, optionMaybe, optional, char, digit, lower, oneOf, many1, (<|>), (<?>),ParseError, modifyState, getState)

-- import Debug.Trace
traceM :: Applicative f => String -> f ()
traceM _ = pure ()

data Expr_Val = Expr_Val_Id Identifier
                | Expr_Val_Lit Integer -- FIXME not all literals are ints
                deriving (Show, Read, Eq, Ord)


data Expr_Tree = Expr_Tree_Leaf Expr_Val
                | Expr_Tree_Inf_Op String Expr_Tree Expr_Tree
                | Expr_Tree_Pre_Op String Expr_Tree
                deriving (Show)


type Precedence = Word8
type ExprParser a = Parsec String Precedence a

max_prec :: Precedence
max_prec = maxBound

infix_ops :: Map.Map String Precedence
infix_ops = Map.fromList [
    ("+", 130),
    ("*", 140)
    ]

prefix_ops :: Set.Set String
prefix_ops = Set.fromList [
    "@",
    "!",
    "~"
    ]

{-
run_expr_tree_maker :: Raw_Expr -> String
run_expr_tree_maker (Raw_Expr input) = do
    case runParser (expr_tree <* eof) max_prec "expr_tree" input of
        Left err -> "error: " ++ (show err)
        Right r -> show r
-}

expr_tree :: String -> Expr_Tree
-- expr_tree input = expr_tree_internal input
expr_tree input = case highest_precedence_infix_op input of
--     Just (whatever) -> undefined
    Just _ -> undefined
    Nothing -> undefined

expr_tree_internal :: String -> Expr_Tree
expr_tree_internal = undefined

expr_tree_internal_what :: String -> Expr_Tree
expr_tree_internal_what = undefined

highest_precedence_infix_op :: String -> Maybe (String, String, String)
highest_precedence_infix_op = undefined

-------------------------------------
--- the NEW WAY
-------------------------------------

type NewExprParser a = Parsec String [Expr_Tree] a

peek :: NewExprParser a -> NewExprParser (Maybe a)
peek p = optionMaybe $ lookAhead (try p)
-- or this?
-- peek p = try (lookAhead p)

new_parse_expr :: NewExprParser Expr_Tree
new_parse_expr = do
    new_parse_expr_with_min_prec 0
    getState >>= (return . head)

sub_expr :: NewExprParser ()
sub_expr = do
    char '(' *> new_parse_expr_with_min_prec 0 <* char ')'

parse_term :: NewExprParser () -- FIXME delete this when done with it
parse_term = do
    parse_term'
    thing <- pop_tree
    traceM $ "found term: " ++ get thing
    push_tree thing
        where
            get (Expr_Tree_Leaf (Expr_Val_Lit x)) = show x
            get _ = error "this is just for debugging, delete this."

parse_term' :: NewExprParser () -- FIXME parse other kinds of things too
parse_term'  = turm <* optional (char ' ') where -- FIXME do spaces properly
    turm = (push_tree =<< fmap (Expr_Tree_Leaf . Expr_Val_Lit . read) (many1 digit))
            <|> (push_tree =<< fmap (Expr_Tree_Leaf . Expr_Val_Id) new_expr_identifier)
            <|> parse_pre_oper_expr
            <|> sub_expr
            <?> "termy"

parse_pre_oper_expr :: NewExprParser ()
parse_pre_oper_expr = do
    oper <- new_prefix_oper
    parse_term
    operand <- pop_tree
    push_tree $ Expr_Tree_Pre_Op oper operand

new_expr_identifier :: NewExprParser Identifier
new_expr_identifier = Identifier <$> many1 lower -- FIXME identifiers are more complex than this

new_oper_char :: NewExprParser Char
new_oper_char = oneOf "*+-/~@!"

new_prefix_oper :: NewExprParser String
new_prefix_oper = many1 new_oper_char

new_infix_oper :: NewExprParser String
new_infix_oper = many1 new_oper_char

-- TODO add whitespace precedence

push_tree :: Expr_Tree -> NewExprParser ()
push_tree tree = modifyState (\list -> tree:list)

pop_tree :: NewExprParser Expr_Tree
pop_tree = do
    thing <- head <$> getState
    modifyState (drop 1)
    return thing

-- FIXME precedence is wrong
new_parse_expr_with_min_prec :: Precedence -> NewExprParser ()
new_parse_expr_with_min_prec min_prec = do
    parse_term
    work min_prec

{-
work :: Precedence -> NewExprParser ()
work min_prec = do
    m_next_oper <- peek new_infix_oper
    case m_next_oper of
        Nothing -> return ()
        Just next_oper -> do
            let next_prec = get_precedence next_oper
            if next_prec > min_prec
                then do
                    new_infix_oper *> optional (char ' ')
                    new_parse_expr_with_min_prec next_prec
                    right <- pop_tree
                    left <- pop_tree
                    push_tree $ Expr_Tree_Inf_Op next_oper left right
                else do -- FIXME precedence is wrong
--                     new_infix_oper *> optional (char ' ')
--                     parse_term
                    right <- pop_tree
                    left <- pop_tree
                    push_tree $ Expr_Tree_Inf_Op next_oper left right
                    work 0
-}

{-
work :: Precedence -> NewExprParser ()
work min_prec = do
    traceM $ "workin, min_prec: " ++ show min_prec
    m_oper <- try new_infix_oper <* optional (char ' ')
    case m_oper of
        "" -> return ()
        oper -> do
            if get_precedence oper < min_prec
                then do
                    parse_term
                    right <- pop_tree
                    left <- pop_tree
                    push_tree $ Expr_Tree_Inf_Op oper left right
                    return ()
                else do
                    parse_term
                    m_next_oper <- peek new_infix_oper
                    case m_next_oper of
                        Nothing -> do
                            right <- pop_tree
                            left <- pop_tree
                            push_tree $ Expr_Tree_Inf_Op oper left right
                        Just next_oper -> do
                            let next_prec = get_precedence next_oper
                            if next_prec > get_precedence oper
        --                     if next_prec > min_prec
                                then do
                                    traceM $ "branch 1"
                                    work next_prec
        --                             work (get_precedence oper)
        --                             work min_prec
                                    right <- pop_tree
                                    left <- pop_tree
                                    push_tree $ Expr_Tree_Inf_Op next_oper left right
                                else do -- FIXME precedence is wrong
                                    traceM $ "branch 2"
                                    right <- pop_tree
                                    left <- pop_tree
                                    push_tree $ Expr_Tree_Inf_Op oper left right
                                    work (get_precedence oper)
        --                             work 0
        --                             work min_prec
-}

work :: Precedence -> NewExprParser ()
work min_prec = do
    traceM $ "workin, min_prec: " ++ show min_prec
    m_oper <- try new_infix_oper
    traceM $  "hosed: " ++ show m_oper
    _ <- optional (char ' ' <|> char '\n')
    traceM $  "hosed"
    case m_oper of
        "" -> return ()
        oper -> do
            traceM $ "oper prec: " ++ show (get_precedence oper)
            parse_term
            if get_precedence oper < min_prec
                then do
                    right <- pop_tree
                    left <- pop_tree
                    push_tree $ Expr_Tree_Inf_Op oper left right
                    work (get_precedence oper)
                else do
                    m_next_oper <- peek new_infix_oper
                    case m_next_oper of
                        Nothing -> do
                            right <- pop_tree
                            left <- pop_tree
                            push_tree $ Expr_Tree_Inf_Op oper left right
                        Just next_oper -> do
                            let next_prec = get_precedence next_oper
                            if next_prec > get_precedence oper
                                then do
                                    traceM $ "branch 1"
                                    work next_prec
                                    right <- pop_tree
                                    left <- pop_tree
                                    push_tree $ Expr_Tree_Inf_Op next_oper left right
                                else do -- FIXME precedence is wrong
                                    traceM $ "branch 2"
                                    right <- pop_tree
                                    left <- pop_tree
                                    push_tree $ Expr_Tree_Inf_Op oper left right
                                    work (get_precedence oper)

get_precedence :: String -> Precedence
get_precedence oper = case Map.lookup oper infix_ops of
    Nothing -> 0
    Just x -> x


run_new_parse_expr :: Raw_Expr -> Either ParseError Expr_Tree
run_new_parse_expr (Raw_Expr input) = runParser (new_parse_expr) [] "source-name" input
